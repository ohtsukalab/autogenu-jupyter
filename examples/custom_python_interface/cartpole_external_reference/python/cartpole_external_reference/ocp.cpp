
// This file was automatically generated by autogenu-jupyter (https://github.com/mayataka/autogenu-jupyter). 
// The autogenu-jupyter copyright holders make no ownership claim of its contents. 

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/eigen.h>
#include <pybind11/numpy.h>

#include "cgmres/types.hpp"
#include "ocp.hpp"

#include <iostream>
#include <stdexcept>
#include <memory>

namespace cgmres {
namespace python {

namespace py = pybind11;

using OCP = OCP_cartpoleExternalReference;

PYBIND11_MODULE(ocp, m) { 

/////////////////////////////////////////////////////////////////////////////
///////////// Custom class that holds external reference ////////////////////
  py::class_<OCP_cartpoleExternalReference::ExternalReference,
             std::shared_ptr<OCP_cartpoleExternalReference::ExternalReference>>(m, "ExternalReference")
    .def(py::init<>())  
    .def_readwrite("cart_position", &OCP_cartpoleExternalReference::ExternalReference::cart_position);
/////////////////////////////////////////////////////////////////////////////


  py::class_<OCP>(m, "OCP")
    .def(py::init<>())  
    .def("clone", [](const OCP& self) { 
       auto copy = self; 
       return copy; 
     }) 
/////////////////////////////////////////////////////////////////////////////
/////////////////////// Custom member variable //////////////////////////////
    .def_readwrite("external_reference", &OCP::external_reference) 
/////////////////////////////////////////////////////////////////////////////
    .def("synchronize", &OCP::synchronize)
    .def("eval_f", [](const OCP& self, const Scalar t,  
                      const VectorX& x, const VectorX& u) { 
        Vector<OCP::nx> dx(Vector<OCP::nx>::Zero());
        self.eval_f(t, x, u, dx); 
        return dx;
     }, py::arg("t"), py::arg("x"), py::arg("u"))
    .def("eval_phix", [](const OCP& self, const Scalar t, const VectorX& x) {
        Vector<OCP::nx> phix(Vector<OCP::nx>::Zero());
        self.eval_phix(t, x, phix);
        return phix;
     }, py::arg("t"), py::arg("x"))
    .def("eval_hx", [](const OCP& self, const Scalar t, 
                       const VectorX& x, const VectorX& u, const VectorX& lmd) {
        Vector<OCP::nx> hx(Vector<OCP::nx>::Zero());
        self.eval_hx(t, x, u, lmd, hx);
        return hx;
     }, py::arg("t"), py::arg("x"), py::arg("u"), py::arg("lmd"))
    .def("eval_hu", [](const OCP& self, const Scalar t,
                       const VectorX& x, const VectorX& u, const VectorX& lmd) {
        Vector<OCP::nuc> hu(Vector<OCP::nuc>::Zero());
        self.eval_hu(t, x, u, lmd, hu);
        return hu;
     }, py::arg("t"), py::arg("x"), py::arg("u"), py::arg("lmd"))
    .def_readwrite("m_c", &OCP::m_c)
    .def_readwrite("m_p", &OCP::m_p)
    .def_readwrite("l", &OCP::l)
    .def_readwrite("g", &OCP::g)
    .def_property("q", 
      [](const OCP& self) { return Map<const VectorX>(self.q.data(), self.q.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != 4) { 
          throw std::invalid_argument("[OCP]: 'q.size()' must be "+std::to_string(4)); 
        } Map<VectorX>(self.q.data(), self.q.size()) = v; })
    .def_property("q_terminal", 
      [](const OCP& self) { return Map<const VectorX>(self.q_terminal.data(), self.q_terminal.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != 4) { 
          throw std::invalid_argument("[OCP]: 'q_terminal.size()' must be "+std::to_string(4)); 
        } Map<VectorX>(self.q_terminal.data(), self.q_terminal.size()) = v; })
    .def_property("x_ref", 
      [](const OCP& self) { return Map<const VectorX>(self.x_ref.data(), self.x_ref.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != 4) { 
          throw std::invalid_argument("[OCP]: 'x_ref.size()' must be "+std::to_string(4)); 
        } Map<VectorX>(self.x_ref.data(), self.x_ref.size()) = v; })
    .def_property("r", 
      [](const OCP& self) { return Map<const VectorX>(self.r.data(), self.r.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != 1) { 
          throw std::invalid_argument("[OCP]: 'r.size()' must be "+std::to_string(1)); 
        } Map<VectorX>(self.r.data(), self.r.size()) = v; })

    .def_readonly_static("ubound_indices", &OCP::ubound_indices)
    .def_property("umin", 
      [](const OCP& self) { return Map<const VectorX>(self.umin.data(), self.umin.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != self.umin.size()) { 
          throw std::invalid_argument("[OCP]: 'umin.size()' must be "+std::to_string(self.umin.size()));
        } Map<VectorX>(self.umin.data(), self.umin.size()) = v; })
    .def_property("umax", 
      [](const OCP& self) { return Map<const VectorX>(self.umax.data(), self.umax.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != self.umax.size()) { 
          throw std::invalid_argument("[OCP]: 'umax.size()' must be "+std::to_string(self.umax.size()));
        } Map<VectorX>(self.umax.data(), self.umax.size()) = v; })
    .def_property("dummy_weight", 
      [](const OCP& self) { return Map<const VectorX>(self.dummy_weight.data(), self.dummy_weight.size()); },
      [](OCP& self, const VectorX& v) { 
        if (v.size() != self.dummy_weight.size()) {
          throw std::invalid_argument("[OCP]: 'dummy_weight.size()' must be "+std::to_string(self.dummy_weight.size()));
        } Map<VectorX>(self.dummy_weight.data(), self.dummy_weight.size()) = v; })

    .def_readonly_static("nx", &OCP::nx)
    .def_readonly_static("nu", &OCP::nu)
    .def_readonly_static("nc", &OCP::nc)
    .def_readonly_static("nh", &OCP::nh)
    .def_readonly_static("nuc", &OCP::nuc)
    .def_readonly_static("nub", &OCP::nub)
    .def("__str__", [](const OCP& self) { 
        std::stringstream ss; 
        ss << self; 
        return ss.str(); 
      }); 

}

} // namespace python
} // namespace cgmres
